---
allowed-tools: Glob, Grep, Read, MultiEdit, Edit, TodoWrite, Task, Bash
argument-hint: [directory-or-pattern]
description: Analyze code structure and add documentation headers to each file
---

# Code Analysis and Documentation Headers

## Step 1: Find all code files
Use Glob to find files matching pattern: ${1:-**/*.{js,ts,jsx,tsx,py}}
IMPORTANT:
- Exclude: docs/, node_modules/, dist/, build/, .next/, __pycache__, *.md files
- Exclude: *.min.js, *.bundle.js, auto-generated files
- Skip files with: // @generated, /* auto-generated */, # Generated by

## Step 2: Create task list
Use TodoWrite to track all files that need documentation:
1. Create todo items for each file found
2. Group by file type and directory
3. Mark as 'pending', 'in_progress', or 'completed'
4. Track which files were skipped (already documented)

## Step 3: Build dependency graph
Analyze all files to create dependency order:
1. Build import graph for all files
2. Sort files by dependency depth (leaf nodes first)
3. Process files from least dependencies to most
This ensures child components are documented before parents

## Step 4: Smart dependency analysis
For each file found:
1. ALWAYS read the file first
2. Check if documentation already exists - if accurate, SKIP
3. Detect file type and framework:
   - **JS/TS**: React Component | Next.js Route | Express API | Vue Component | Hook | Service | Config
   - **Python**: Django Model/View | FastAPI Router | Flask Blueprint | SQLAlchemy Model | Pydantic Schema | Celery Task | pytest Test
4. Read imports based on language:
   - **JS/TS**: import/require statements, dynamic imports, lazy loading
   - **Python**: import/from statements, __import__(), importlib
5. Use Grep to find who imports this:
   - **JS/TS**: search for filename in import/require statements
   - **Python**: search for module name in: `import module`, `from module import`,
     `from . import`, `from ..package import`, relative imports
6. Detect circular dependencies and note them as warnings
7. Check for environment variables:
   - **JS/TS**: process.env.X
   - **Python**: os.environ, os.getenv(), python-dotenv
8. Find associated test files:
   - **JS/TS**: *.test.js, *.spec.ts, __tests__/
   - **Python**: test_*.py, *_test.py, tests/, pytest files

## Step 5: Generate or update file header documentation
Based on full context from related files, create/update headers:

For JavaScript/TypeScript files:
```javascript
/**
 * @purpose [What problem this solves - one line]
 * @llm-note
 *   Dependencies: imports from [lib/api.js, utils/format.js] | imported by [app/page.tsx, components/Header.tsx] | tested by [__tests__/module.test.js]
 *   Data flow: receives {user: User, settings: Settings} from page.tsx → validates → fetches from api.js → transforms → returns {formattedData: DataResponse}
 *   State/Effects: updates Redux store.user | calls API POST /users | emits 'user-updated' event | writes to localStorage
 *   Integration: exposes {getUserData, updateUser} | uses parent's onUpdate callback | implements AuthMiddleware interface
 *   Performance: caches user data 5min | debounces API calls 300ms | lazy loads ProfileImage
 *   Errors: throws UserNotFoundError | handles network timeout | fallback to cache
 */
```

For Python files:
```python
"""
Purpose: [What problem this solves - one line]
LLM-Note:
  Dependencies: imports from [lib/database.py, utils/validator.py] | imported by [api/routes.py, workers/processor.py] | tested by [tests/test_module.py]
  Data flow: receives request_data: Dict[str, Any] from routes.py → validates via validator.py → queries database.py → returns ProcessedResult
  State/Effects: modifies global_cache | writes to PostgreSQL | publishes to Redis queue | logs to logging.getLogger(__name__)
  Integration: exposes process_data(), get_status() | implements DataProcessor ABC | uses @celery.task decorator | FastAPI dependency
  Performance: @lru_cache(maxsize=128) | asyncio.gather() for parallel | connection pool 10 | batch size 100
  Errors: raises ValidationError | @retry(stop_after_attempt=3) | circuit breaker | dead letter queue
"""
```

The LLM-Note MUST include ALL of these aspects:
1. **File Dependencies**:
   - Imports: [actual file paths this imports from]
   - Imported by: [use Grep to find who imports this file]
   - Test files: [any test files that test this module]

2. **Data Flow**:
   - Input: [what data comes in, from which files/sources]
   - Processing: [key transformations or business logic]
   - Output: [what data goes out, to which files/destinations]

3. **State & Side Effects**:
   - State mutations: [what global/shared state it modifies]
   - Side effects: [API calls, file I/O, DOM updates, database writes]
   - Event emissions: [events triggered, subscribers affected]

4. **Integration Points**:
   - APIs exposed: [public methods/functions other files use]
   - Callbacks used: [callbacks it receives from parent components]
   - Hooks/middleware: [lifecycle hooks, middleware it provides/uses]
   - External services: [third-party APIs, databases, services it connects to]

## Step 5: Smart header insertion/update
- If NO header exists: Add new header at file top
- If header EXISTS: Update it based on new analysis
- If header is ACCURATE: Skip the file
- Always use MultiEdit or Edit to preserve existing code

## Step 6: Update todo list and track progress
Use TodoWrite throughout the process:
1. Mark each file as 'in_progress' when starting
2. Mark as 'completed' when documentation added/updated
3. Mark as 'skipped' if already has accurate docs
4. Provide final summary:
   - Total files processed
   - Files updated vs skipped
   - Circular dependencies found
   - Missing test coverage
   - Critical warnings discovered
DO NOT create any new documentation files or modify any markdown files

## Step 7: File-type specific focus
**JavaScript/TypeScript:**
- **Components**: Props/State types, events emitted, context consumed, render conditions
- **API Routes**: Request/response types, middleware chain, status codes, error responses
- **Utilities**: Input/output types, pure functions, memoization, edge cases
- **Hooks**: useEffect deps, cleanup returns, custom hook composition
- **Services**: Axios/fetch configs, interceptors, retry logic, caching strategy

**Python:**
- **Classes**: __init__ params, @property decorators, inheritance (ABC, Protocol), __slots__
- **API Endpoints**: @app.route or @router decorators, Pydantic models, HTTPException handling
- **Async Functions**: async/await, asyncio.create_task(), gather(), event loops
- **Data Classes**: @dataclass fields, field(default_factory), __post_init__, asdict()
- **Decorators**: functools.wraps, *args/**kwargs handling, closure state
- **Type Hints**: Generic[T], Union, Optional, TypeVar, Protocol definitions

## Step 8: Critical warnings to include
Add warnings in LLM-note when detected:
- ⚠️ Circular dependency with [file.js]
- ⚠️ Performance: expensive operation in render/hot path
- ⚠️ Security: handles sensitive data/credentials
- ⚠️ Deprecated: scheduled for removal in v2.0
- ⚠️ TODO: unfinished implementation at line X

## Step 9: Process checklist
Before marking a file as completed, verify:
- [ ] Read all imported files for context
- [ ] Found all files that import this one (used Grep)
- [ ] Identified correct file type (Component/Class/API/etc)
- [ ] Documented actual file paths, not generic names
- [ ] Included data types in data flow
- [ ] Listed all side effects and state changes
- [ ] Added performance notes if relevant
- [ ] Added warnings for issues found
- [ ] Checked for associated test files
- [ ] Updated TodoWrite status

## Step 10: Important principles
- ONLY modify code files (.js/.ts/.jsx/.tsx/.py) - never .md files
- NEVER touch docs/ folder or any documentation files
- ONLY add/update comment headers at the top of code files
- ALWAYS read related files before documenting
- Keep docs minimal but include LLM context hints
- Focus on relationships and data flow over implementation
- Update stale docs when code has changed
- Skip files with accurate existing documentation